<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>排序测试</title>
    <style>
        html,body{
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
            font-size: 16px;
            color: #212121;
        }
        .test{
            height: 100%;
            width: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #eee;
        }
    </style>
</head>
<body>
    <div class="test">
        chrome is the best test tools;
    </div>
    <script>
        let sortArray = [];
        // 生成若干个随机整数
        function mathRandom(num=10000) {
            let arrRes = [];
            for(let i=0; i<num; i++) {
                arrRes.push(parseInt(Math.random()*100000));
            }
            return arrRes;
        }

        sortArray = mathRandom(20000);
        
        const testSortTimeAnRes = function(sortFunc, sortFuncName, needSortArray) {
            let startTime = new Date().getTime();

            let res = sortFunc(needSortArray);

            let endTime = new Date().getTime();
            console.log(`${sortFuncName}耗时：`, endTime-startTime, "ms");
            console.log(`${sortFuncName}结果：`, res);
        }
        /**
         * 冒泡排序方法 先把大的数据冒泡上去[升序]
         * @param {*} needSortArray 是一个待排序的init 数组【未校验】
         */
        function Bubble_Sort(needSortArray=[]) {
            const isArray = Object.prototype.toString.call(needSortArray) === '[object Array]',
                isIntArray = needSortArray.every( item => typeof item === 'number');
            if(!isArray || !isIntArray) { // 校验整数数组
                return needSortArray;
            }
            const arrayLen = needSortArray.length;
            let okFlag = false;
            for(let i=0; i<arrayLen-1 && !okFlag; i++) {
                okFlag = true; // 假设已经OK
                for(let j=0; j<arrayLen-i-1; j++) {
                    let beforeNum = needSortArray[j],
                        afterNum = needSortArray[j+1];
                    if(beforeNum > afterNum) {
                        needSortArray[j] = afterNum;
                        needSortArray[j+1] = beforeNum;
                        okFlag = false; // 如果有变化说明排序还没完成
                    }
                }
            }
            return needSortArray;
        }
        testSortTimeAnRes(Bubble_Sort, '冒泡排序', [...sortArray]);

        /**
         * 选择排序
         * @param {*} needSortArray 待排序整形数组
         */
        function Select_Sort(needSortArray=[]) {
            const isArray = Object.prototype.toString.call(needSortArray) === '[object Array]',
                isIntArray = needSortArray.every( item => typeof item === 'number');
            if(!isArray || !isIntArray) { // 校验整数数组
                return needSortArray;
            }
            let minIndex = 0,
                arrayLen = needSortArray.length;
            for(let i=0; i<arrayLen-1; i++) {
                minIndex = i;
                for(let n=i+1; n<arrayLen; n++) {
                    needSortArray[minIndex] > needSortArray[n] && (minIndex=n);
                }
                if(i !== minIndex) {
                    let temp = needSortArray[i];
                    needSortArray[i] = needSortArray[minIndex];
                    needSortArray[minIndex] = temp;
                }
            }
            return needSortArray;
        }
        testSortTimeAnRes(Select_Sort, '选择排序', [...sortArray]);

        /**
         * 插入排序
         * @param {*} needSortArray 待排序数组
         */
        function Insertion_Sort(needSortArray=[]) {
            const isArray = Object.prototype.toString.call(needSortArray) === '[object Array]',
                isIntArray = needSortArray.every( item => typeof item === 'number');
            if(!isArray || !isIntArray) { // 校验整数数组
                return needSortArray;
            }
            let minIndex = 0,
                arrayLen = needSortArray.length;
            for(let i=1; i<arrayLen; i++) {
                let currInsertNum = needSortArray.splice(i, 1)[0];
                for(let j=i-1; j>=0; j--) {
                    if(currInsertNum > needSortArray[j]) {
                        needSortArray.splice(j+1, 0, currInsertNum);
                        break;
                    } else if(j===0) {
                        needSortArray.unshift(currInsertNum);
                    }
                }
            }
            return needSortArray;
        }
        testSortTimeAnRes(Insertion_Sort, '插入排序', [...sortArray]);

        /**
         * 希尔排序
         * @param {*} needSortArray 
         */
         function Shell_Sort(needSortArray=[]){
            const isArray = Object.prototype.toString.call(needSortArray) === '[object Array]',
                isIntArray = needSortArray.every( item => typeof item === 'number');
            if(!isArray || !isIntArray) { // 校验整数数组
                return needSortArray;
            }
            let shell_gap_step = 2,
                arrayLen = needSortArray.length,
                initGap = Math.floor(arrayLen / shell_gap_step);
            //增量gap，并逐步缩小增量
            // debugger;
            for(let gap=initGap;gap>0;gap=Math.floor(gap/ shell_gap_step)){
                //从第gap个元素，逐个对其所在组进行直接插入排序操作
                for(let i=gap;i<arrayLen;i++){
                    let j = i;
                    while(j-gap>=0 && needSortArray[j]<needSortArray[j-gap]){
                        //插入排序采用交换法
                        let temp = needSortArray[j];
                        needSortArray[j] = needSortArray[j-gap];
                        needSortArray[j-gap] = temp;
                        j-=gap;
                    }
                }
            }
            return needSortArray;
        }
        testSortTimeAnRes(Shell_Sort, '希尔排序', [...sortArray]);
    </script>
</body>
</html>